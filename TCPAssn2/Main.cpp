/*----------------------------------------------------------------------
-- SOURCE FILE:	Main.cpp		- A TCP/UDP Analysis terminal program
--								  that compares sending packets using
--								  TCP protocol and UDP protocol.
--
-- PROGRAM:		TCPAssn2
--
-- FUNCTIONS:
--				int WINAPI WinMain(HINSTANCE hInst, HINSTANCE hprevInstance,
--								   LPSTR lspszCmdParam, int nCmdShow)
--				LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
--				BOOL CALLBACK DialogProc(HWND H, UINT M, WPARAM W, LPARAM L);
--				bool InitializeWindows(HINSTANCE hInst, int nCmdShow);
--				bool UploadFile();
--				bool PacketizeFile(std::string filePath);
--				bool SaveToFile();
--				void PrintChar(HWND hwnd, char* character, unsigned int row, int* X, int* Y);
--				void ClearScreen(HWND hwnd);
--				void CleanUp();
--
--
--
-- DATE:		February 14, 2018
--
-- DESIGNER:	Luke Lee
--
-- PROGRAMMER:	Luke Lee
--
-- NOTES:
-- This is the entry point for the program. This method is responsible
-- for creating the GUI for simple user interface.
--
-- The program allows user to select a host type (client or server)
-- Client will send packets of file to the server with specified
-- packet size and number of packets to send.
--
-- User can also select which protocol to use (TCP or UDP). For the
-- purpose of this assignment, the results were taken down to perform
-- analysis and comparison between TCP and UDP protocols.
----------------------------------------------------------------------*/

#include "Global.h"
#include "Main.h"
#include "resource.h"
#include "TcpClntSvr.h"

using namespace tcpudp;

/*----------------------------------------------------------------------
-- FUNCTION:	WinMain
--
-- DATE:		January 17, 2018
--
-- DESIGNER:	Luke Lee
--
-- PROGRAMMER:	Luke Lee
--
-- INTERFACE:	int WINAPI WinMain(HINSTANCE hInst
--								 , HINSTANCE hprevInstance,
--								 , LPSTR lspszCmdParam, int nCmdShow)
--
-- ARGUMENT: hInst				- A handle to the current instance of the
--								  application.
--			 hprevInstance		- A handle to the previous instance of
--								  the application.
--			 lspszCmdParam		- The command parameter for the
--								  application.
--			 nCmdShow			- A value to determine how the Window is
--								  is to be shown.
--
-- RETURNS:	 int				- 0 if this function terminates before
--								  entering the Message loop. If this
--								  function terminates by receiving a
--								  WM_QUIT Message, the exit value in that
--								  Message's wParam parameter.
--
-- NOTES:
-- Main function of this program. Its main role is creating Window and
-- initialize communciation Handler, as well as reading Windows Events
-- including user keystroke Events. Messages generated by Events captured
-- by this function are sent to WndProc
----------------------------------------------------------------------*/
int WINAPI WinMain(HINSTANCE hInst, HINSTANCE hprevInstance, LPSTR lspszCmdParam, int nCmdShow)
{
	MSG Msg;
	hInst = hInst;

	if (!InitializeWindows(hInst, nCmdShow))
	{
		return 0;
	}

	while (GetMessage(&Msg, NULL, 0, 0))
	{
		TranslateMessage(&Msg);
		DispatchMessage(&Msg);
	}

	return Msg.wParam;
}

/*----------------------------------------------------------------------
-- FUNCTION:	InitializeWindows
--
-- DATE:		January 17, 2018
--
-- DESIGNER:	Luke Lee
--
-- PROGRAMMER:	Luke Lee
--
-- INTERFACE:	bool InitializeWindows(HINSTANCE hInst, int nCmdShow)
--
-- ARGUMENT:	hInst			- A handle to the current instance of the
--								  application.
--				nCmdShow		- A value to determine how the Window is
--								  is to be shown.
--
-- RETURNS:		bool			- true if the main Windows is created
--								  successfully; false otherwise.
--
-- NOTES:
-- This function initializes required parameters for the TCP/UDP analysis
-- terminal Windows and opens the windows. It assigns a process
-- to the program which will listen to user's keystroke or menu item
-- clicks input and response accordingly.
----------------------------------------------------------------------*/
bool tcpudp::InitializeWindows(HINSTANCE hInst, int nCmdShow)
{
	// application Window values
	const int intWindowW = 500; // Window width
	const int intWindowH = 250; // Window height

	WNDCLASSEX Wcl;

	Wcl.cbSize = sizeof(WNDCLASSEX);
	Wcl.style = CS_HREDRAW | CS_VREDRAW;
	Wcl.hIcon = LoadIcon(hInst, IDI_APPLICATION); // large icon
	Wcl.hIconSm = NULL; // use small version of large icon
	Wcl.hCursor = LoadCursor(NULL, IDC_ARROW); // cursor style

	Wcl.lpfnWndProc = WndProc;
	Wcl.hInstance = hInst;
	//Wcl.hbrBackground	= (HBRUSH)GetStockObject(WHITE_BRUSH);
	Wcl.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
	Wcl.lpszClassName = tchrProgramName;

	Wcl.lpszMenuName = TEXT("MYMENU"); // The menu Class
	Wcl.cbClsExtra = 0; // no extra memory needed
	Wcl.cbWndExtra = 0;

	if (!RegisterClassEx(&Wcl))
	{
		MessageBox(NULL, "TCP/UDP Analysis Terminal couldn't start!", NULL, MB_OK | MB_ICONSTOP);
		return false;
	}

	hwnd = CreateWindow(tchrProgramName, tchrProgramName, WS_OVERLAPPEDWINDOW
		, 10, 10, intWindowW, intWindowH, NULL, NULL, hInst, NULL);

	ShowWindow(hwnd, nCmdShow);
	UpdateWindow(hwnd);

	// Disable menuitems to start with
	EnableMenuItem(GetMenu(hwnd), IDM_TX, MF_DISABLED);
	EnableMenuItem(GetMenu(hwnd), IDM_RX, MF_DISABLED);
	EnableMenuItem(GetMenu(hwnd), IDM_SETTINGS, MF_DISABLED);
	EnableMenuItem(GetMenu(hwnd), IDM_STOP, MF_DISABLED);

	return true;
}


/*----------------------------------------------------------------------
-- FUNCTION:	WndProc
--
-- DATE:		February 14, 2018
--
-- DESIGNER:	Luke Lee
--
-- PROGRAMMER:	Luke Lee
--
-- INTERFACE:	LRESULT CALLBACK WndProc(HWND hwnd, UINT Message,
--										 WPARAM wParam, LPARAM lParam)
--
-- ARGUMENT:	hwnd			- A handle to the Window.
--				Message			- A Message to process.
--				wParam			- Additional Message information
--				lParam			- Additional Message information
--
-- RETURNS:		LRESULT			- 0 if defined behavior is successful.
--								  If the behavior for the received Message
--								  is not defined, the return value of
--								  DefWindowProc.
--
-- NOTES:
-- This function receives Messages from WinMain and determines behavior
-- in switch statements. Selecting on menu items defined in Menu.h and Menu.rc
-- is detected in this function, and it behaves accordingly.
----------------------------------------------------------------------*/
LRESULT CALLBACK tcpudp::WndProc(HWND hwnd, UINT Message, WPARAM wParam, LPARAM lParam)
{
	char bufferWrite[2] = "";
	HDC hdc;
	PAINTSTRUCT paintstruct;
	TEXTMETRIC tm;
	HINSTANCE manInst;

	if (hostType == CLIENT)
	{
		EnableMenuItem(GetMenu(hwnd), IDM_TX, MF_ENABLED);
		EnableMenuItem(GetMenu(hwnd), IDM_SETTINGS, MF_ENABLED);
		EnableMenuItem(GetMenu(hwnd), IDM_RX, MF_DISABLED);
	}
	else if (hostType == SERVER)
	{
		EnableMenuItem(GetMenu(hwnd), IDM_RX, MF_ENABLED);
		EnableMenuItem(GetMenu(hwnd), IDM_SETTINGS, MF_ENABLED);
		EnableMenuItem(GetMenu(hwnd), IDM_TX, MF_DISABLED);
	}

	if (Message == WM_SOCKET)
	{
		if (clntConnected)
		{
			clntInfo->connected = &ptclConnected;
			// client proc
			ClientSide::ClntProc(hwnd, Message, wParam, lParam);
		}
		else if (svrConnected)
		{
			svrInfo->connected = &ptclConnected;
			// server proc
			ServerSide::SvrProc(hwnd, Message, wParam, lParam);
		}
	}

	switch (Message)
	{
	case WM_COMMAND:
		switch (LOWORD(wParam)) // menu items
		{
			// under "Host Type" menu popup
		case IDM_CLIENT: // set host type to client
			if (ptclConnected)
			{
				MessageBox(hwnd, "Please stop transfer/receive first.", "Error", MB_OK);
			}
			else
			{
				CheckMenuItem(GetMenu(hwnd), IDM_CLIENT, MF_CHECKED);
				hostType = CLIENT;
				svrConnected = false;
				CheckMenuItem(GetMenu(hwnd), IDM_SERVER, MF_UNCHECKED);
				if (clntInfo == nullptr)
					clntInfo = new clientInfo();
				DialogBox(hInst, MAKEINTRESOURCE(IDD_TxDIALOG), hwnd, (DLGPROC)DialogProc);
			}
			break;

		case IDM_SERVER: // set host type to server
			if (ptclConnected)
			{
				MessageBox(hwnd, "Please stop transfer/receive first.", "Error", MB_OK);
			}
			else
			{
				CheckMenuItem(GetMenu(hwnd), IDM_SERVER, MF_CHECKED);
				hostType = SERVER;
				clntConnected = false;
				CheckMenuItem(GetMenu(hwnd), IDM_CLIENT, MF_UNCHECKED);
				if (svrInfo == nullptr)
					svrInfo = new serverInfo();
				DialogBox(hInst, MAKEINTRESOURCE(IDD_TxDIALOG), hwnd, (DLGPROC)DialogProc);
			}
			break;

			// under "File" menu popup
		case IDM_TX: // Tx a file to server (must be a client)
			fileUpload = UploadFile();
			break;

		case IDM_RX: // Rx a file from client (must be a server)
			fileSave = SaveToFile();
			break;

		case IDM_SETTINGS: // open the settings dialog
			DialogBox(hInst, MAKEINTRESOURCE(IDD_TxDIALOG), hwnd, (DLGPROC)DialogProc);
			break;

		case IDM_START:
			if (hostType == CLIENT)
			{
				if (fileUpload)
				{
					clntConnected = ClientSide::ClntConnect(clntInfo);
					ptclConnected = clntConnected;
					EnableMenuItem(GetMenu(hwnd), IDM_TX, MF_DISABLED);
					EnableMenuItem(GetMenu(hwnd), IDM_RX, MF_DISABLED);
					EnableMenuItem(GetMenu(hwnd), IDM_SETTINGS, MF_DISABLED);
					// WSAConnect called here
					// should trigger WM_SOCKET message with FD_CONNECT
				}
				else
				{
					MessageBox(hwnd, "File upload failed; please specify a valid file to transfer.", "Error", MB_ICONERROR | MB_OK);
					break;
				}
			}
			else if (hostType == SERVER)
			{
				if (fileSave)
				{
					svrInfo->hwnd = &hwnd;
					svrInfo->port = port;
					svrInfo->send_times = send_times;
					svrInfo->packetSize = p_size;
					svrInfo->isTCP = isTCP;
					svrConnected = ServerSide::SvrConnect(svrInfo);
					ptclConnected = svrConnected;
					EnableMenuItem(GetMenu(hwnd), IDM_RX, MF_DISABLED);
					EnableMenuItem(GetMenu(hwnd), IDM_TX, MF_DISABLED);
					EnableMenuItem(GetMenu(hwnd), IDM_SETTINGS, MF_DISABLED);
				}
				else
				{
					MessageBox(hwnd, "Please specify a file to save to first!", "Error", MB_ICONERROR | MB_OK);
					break;
				}
			}
			else
			{
				MessageBox(hwnd, "Please select a host type first!", "Error", MB_ICONERROR | MB_OK);
				break;
			}
			if (ptclConnected)
			{
				EnableMenuItem(GetMenu(hwnd), IDM_START, MF_DISABLED);
				if (hostType == CLIENT)
				{
					sprintf_s(str, "Transferring file... Please hit \"Stop\" to stop transfer.");
					for (unsigned int i = 0; i < strlen(str); i++)
					{
						PrintChar(hwnd, &str[i], 0, &X, &Y);
						Y = INITIAL_Y;
					}
					X = INITIAL_X;
					EnableMenuItem(GetMenu(hwnd), IDM_STOP, MF_ENABLED);
				}
				else if (hostType == SERVER)
				{
					if (isTCP)
						sprintf_s(str, "Receiving file... Please wait for client to stop transfer.");
					else
					{
						sprintf_s(str, "Receiving file... Please press \"Stop\" to stop receiving.");
						EnableMenuItem(GetMenu(hwnd), IDM_STOP, MF_ENABLED);
					}
					for (unsigned int i = 0; i < strlen(str); i++)
					{
						PrintChar(hwnd, &str[i], 0, &X, &Y);
						Y = INITIAL_Y;
					}
					X = INITIAL_X;
				}
			}
			break;

		case IDM_STOP:
			ptclConnected = false;
			if (hostType == CLIENT)
			{
				PostMessage(hwnd, WM_SOCKET, *clntInfo->sendSocket, FD_CLOSE);
				EnableMenuItem(GetMenu(hwnd), IDM_TX, MF_ENABLED);
				EnableMenuItem(GetMenu(hwnd), IDM_SETTINGS, MF_ENABLED);
				sprintf_s(str, "Transfer stopped.");
			}
			else if (hostType == SERVER)
			{
				PostMessage(hwnd, WM_SOCKET, *svrInfo->recvSocket, FD_CLOSE);
				EnableMenuItem(GetMenu(hwnd), IDM_RX, MF_ENABLED);
				EnableMenuItem(GetMenu(hwnd), IDM_SETTINGS, MF_ENABLED);
				sprintf_s(str, "Receive completed!");
			}
			EnableMenuItem(GetMenu(hwnd), IDM_START, MF_ENABLED);
			EnableMenuItem(GetMenu(hwnd), IDM_STOP, MF_DISABLED);
			ClearScreen(hwnd);
			for (unsigned int i = 0; i < strlen(str); i++)
			{
				PrintChar(hwnd, &str[i], 0, &X, &Y);
				Y = INITIAL_Y;
			}
			X = INITIAL_X;
			break;

		case IDM_ABOUT: // Open About dialog
			MessageBox(hwnd, "TCP/UDP Protocol Analysis Terminal v.1\nCreated by L.Lee", "About", MB_ICONINFORMATION | MB_OK);
			break;

		case IDM_HELP: // Open user manual
			manInst = ShellExecute(NULL, "open", "UserManual.pdf", NULL, NULL, SW_SHOW);
			if ((int)manInst == ERROR_FILE_NOT_FOUND)
			{
				MessageBox(NULL,
					TEXT("UserManual.pdf not found."), TEXT("Error"),
					MB_ICONHAND | MB_OK);
			}
			break;

		case IDM_EXIT: // Exit program
			if (IDOK == MessageBox(hwnd, "OK to close window?", "Exit", MB_ICONQUESTION | MB_OKCANCEL))
			{
				CleanUp();
			}
			break;
		}
		break;
		/*
	case WM_PAINT: // process a repaint message
		for (unsigned int i = 0; i < strlen(str); i++)
		{
			PrintChar(hwnd, &str[i], 0, &X, &Y);
			Y = INITIAL_Y;
		}
		X = INITIAL_X;
		break;
		*/
	case WM_CLOSE: // terminate program
		if (IDOK == MessageBox(hwnd, "OK to close window?", "Exit", MB_ICONQUESTION | MB_OKCANCEL))
		{
			CleanUp();
		}
		break;

	default:
		return DefWindowProc(hwnd, Message, wParam, lParam);
	}
	return 0;
}

/*----------------------------------------------------------------------
-- FUNCTION:	DialogProc
--
-- DATE:		February 14, 2018
--
-- DESIGNER:	Luke Lee
--
-- PROGRAMMER:	Luke Lee
--
-- INTERFACE:	BOOL CALLBACK DialogProc(HWND hwnd, UINT Message,
--										 WPARAM wParam, LPARAM lParam)
--
-- ARGUMENT:	hwnd			- A handle to the Window.
--				Message			- A Message to process.
--				wParam			- Additional Message information
--				lParam			- Additional Message information
--
-- RETURNS:		BOOL			- 0 if defined behavior is successful.
--								  If the behavior for the received Message
--								  is not defined, the return value of
--								  DefWindowProc.
--
-- NOTES:
-- This function initializes a dialog for transfer settings, and sets
-- the settings for client or server transfer accordingly.
----------------------------------------------------------------------*/
BOOL CALLBACK tcpudp::DialogProc(HWND hwnd, UINT Message, WPARAM wParam, LPARAM lParam)
{
	switch (Message)
	{
	case WM_INITDIALOG:
		// set default to IP Address radio and TCP radio
		if (isIPAddress)
			CheckRadioButton(hwnd, IDC_RADIO_IP, IDC_RADIO_HOST, IDC_RADIO_IP);
		else
			CheckRadioButton(hwnd, IDC_RADIO_IP, IDC_RADIO_HOST, IDC_RADIO_HOST);
		if (isTCP)
			CheckRadioButton(hwnd, IDC_RADIO_TCP, IDC_RADIO_UDP, IDC_RADIO_TCP);
		else
			CheckRadioButton(hwnd, IDC_RADIO_TCP, IDC_RADIO_UDP, IDC_RADIO_UDP);
		if (hostType == SERVER)
		{
			EnableWindow(GetDlgItem(hwnd, IDC_IP_INPUT), false);
			EnableWindow(GetDlgItem(hwnd, IDC_RADIO_IP), false);
			EnableWindow(GetDlgItem(hwnd, IDC_RADIO_HOST), false);
		}
		SetDlgItemText(hwnd, IDC_IP_INPUT, server_input);
		SetDlgItemText(hwnd, IDC_PSIZE_INPUT, std::to_string(p_size).c_str());
		SetDlgItemText(hwnd, IDC_TIMES_INPUT, std::to_string(send_times).c_str());
		SetDlgItemText(hwnd, IDC_PORT_INPUT, std::to_string(port).c_str());
		break;

	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDOK:
			if (!IsDlgButtonChecked(hwnd, IDC_RADIO_IP))
			{
				isIPAddress = false;
			}
			if (!IsDlgButtonChecked(hwnd, IDC_RADIO_TCP))
			{
				isTCP = false;
			}
			if (hostType == CLIENT)
			{
				GetDlgItemText(hwnd, IDC_IP_INPUT, server_input, BUFSIZ);
			}

			GetDlgItemText(hwnd, IDC_PSIZE_INPUT, p_size_str, BUFSIZ);
			GetDlgItemText(hwnd, IDC_TIMES_INPUT, send_time_str, BUFSIZ);
			GetDlgItemText(hwnd, IDC_PORT_INPUT, port_str, BUFSIZ);

			if (strcmp(p_size_str, "") != 0) {
				char* endstr;
				p_size = strtol(p_size_str, &endstr, 10);
				if (strcmp(endstr, "") != 0)
					p_size = DEF_P_SIZE;
			}
			if (strcmp(send_time_str, "") != 0) {
				char* endstr;
				send_times = strtol(send_time_str, &endstr, 10);
				if (strcmp(endstr, "") != 0)
					send_times = DEF_SEND_TIMES;
			}
			if (strcmp(port_str, "") != 0) {
				char* endstr;
				port = strtol(port_str, &endstr, 10);
				if (strcmp(endstr, "") != 0)
					port = DEF_P_SIZE;
			}
			//EndDialog(hwnd, 0);
			//break;
		case IDCANCEL:
			EndDialog(hwnd, 0);
			break;
		}

	}
	return 0;
}

/*----------------------------------------------------------------------
-- FUNCTION:	UploadFile
--
-- DATE:		February 14, 2018
--
-- DESIGNER:	Luke Lee
--
-- PROGRAMMER:	Luke Lee
--
-- INTERFACE:	void UploadFile()
--
-- ARGUMENT:	void
--
-- RETURNS:		void
--
-- NOTES:
-- This function opens up a file upload browser and allows the user to
-- specify a file to transfer from.
----------------------------------------------------------------------*/
bool tcpudp::UploadFile()
{
	OPENFILENAME ofn; // common dialog box structure
	char szFile[300]; // buffer for file name

	// Initialize OPENFILENAME
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hwnd;
	ofn.lpstrFile = szFile;

	ofn.lpstrFile[0] = '\0';
	ofn.nMaxFile = sizeof(szFile);
	ofn.lpstrFilter = "All\0*.*\0Text\0*.TXT\0";
	ofn.nFilterIndex = 1;
	ofn.lpstrFileTitle = NULL;
	ofn.nMaxFileTitle = 0;
	ofn.lpstrInitialDir = NULL;
	ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST;

	// Display the Open dialog box. 
	if (GetOpenFileName(&ofn) == TRUE)
	{
		return PacketizeFile(ofn.lpstrFile);
	}
	else
	{
		MessageBox(hwnd, TEXT("Unable to open specified file"), TEXT("Access Denied"), MB_ICONHAND | MB_OK);
		return false;
	}
}

/*----------------------------------------------------------------------
-- FUNCTION:	PacketizeFile
--
-- DATE:		February 14, 2018
--
-- DESIGNER:	Luke Lee
--
-- PROGRAMMER:	Luke Lee
--
-- INTERFACE:	bool PacketizeFile(std::string filePath)
--
-- ARGUMENT:	filePath		- string indicating the file path
--
-- RETURNS:		bool			- returns true if file packetized
--								  successfully
--
-- NOTES:
-- This function puts the uploaded file into a custom client info struct
-- and passes to the client/server class.
----------------------------------------------------------------------*/
bool tcpudp::PacketizeFile(std::string filePath)
{
	std::ifstream fileRead(filePath, std::ios::binary | std::ios::ate);
	std::streamsize fileSize = fileRead.tellg();
	fileRead.seekg(0, std::ios::beg);

	if (fileSize < 0) // no file found (tellg() returns -1)
	{
		// error msg
		return false;
	}

	//std::vector<char> readBuffer(p_size);
	clntInfo->sendBuffer = new char[p_size];

	// in case specified packet size is greater than file size
	if (p_size > fileSize)
	{
		if (!fileRead.read(clntInfo->sendBuffer, fileSize))
		{
			// error message
			return false;
		}
	}
	else
	{
		if (!fileRead.read(clntInfo->sendBuffer, p_size))
		{
			// error message
			return false;
		}
	}

	// successful read
	clntInfo->hwnd = &hwnd;
	clntInfo->server_input = server_input;
	clntInfo->port = port;
	clntInfo->send_times = send_times;
	clntInfo->isIPAddress = isIPAddress;
	clntInfo->packetSize = p_size;
	clntInfo->isTCP = isTCP;

	return true;
}

/*----------------------------------------------------------------------
-- FUNCTION:	SaveToFile
--
-- DATE:		February 14, 2018
--
-- DESIGNER:	Luke Lee
--
-- PROGRAMMER:	Luke Lee
--
-- INTERFACE:	bool SaveToFile()
--
-- ARGUMENT:	void
--
-- RETURNS:		bool			- returns true if file opens successfully
--
-- NOTES:
-- This function puts the uploaded file into a custom client info struct
-- and passes to the client/server class.
----------------------------------------------------------------------*/
bool tcpudp::SaveToFile()
{
	OPENFILENAME ofn;

	char szFileName[MAX_PATH] = "";
	ZeroMemory(&ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hwnd;

	ofn.lpstrFilter = "Text Files (*.txt)\0*.txt\0All Files (*.*)\0*.*\0";
	ofn.lpstrFile = szFileName;
	ofn.nMaxFile = MAX_PATH;
	ofn.Flags = OFN_EXPLORER | OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | OFN_CREATEPROMPT;
	ofn.lpstrDefExt = "txt";

	if (GetSaveFileName(&ofn) == TRUE)
	{
		svrInfo->svFilePath = ofn.lpstrFile;
		return true;
	}
	return false;
}


/*----------------------------------------------------------------------
-- FUNCTION:	PrintChar
--
-- DATE:		January 17, 2018
--
-- DESIGNER:	Luke Lee
--
-- PROGRAMMER:	Luke Lee
--
-- INTERFACE:	void PrintChar(HWND hwnd, char* character,
--							   unsigned int row, int* X, int* Y)
--
-- ARGUMENT:	hwnd		- Windows handle access GUI information
--				character	- char pointer to a character to draw on the Window.
--				row			- Line number to draw a character string on.
--							  Starts from 0.
--				X			- int Pointer to x-coordinate of a caret to print
--							  characters
--				Y			- int Pointer to y-coordinate of a caret to print
--							  characters
--
-- RETURNS:		void
--
-- NOTES:
-- This function takes a string and displays it (one character) on the
-- device context. On the same row, the X coordinate is increased
-- accordingly as each character gets printed.
----------------------------------------------------------------------*/
void tcpudp::PrintChar(HWND hwnd, char* character, unsigned int row, int* X, int* Y)
{
	HDC hdc;
	TEXTMETRIC tm;
	SIZE size;
	RECT rect;
	int heightToAdd = 0;

	hdc = GetDC(hwnd); // Acquire DC
	GetTextMetrics(hdc, &tm); // get text metrics
	GetTextExtentPoint32(hdc, character, 1, &size); // compute length of a string 
													//move to this row
	while (row > 0)
	{
		heightToAdd += tm.tmHeight + tm.tmExternalLeading; // next line
		row--;
	}
	*Y += heightToAdd;

	TextOut(hdc, *X, *Y, character, 1);  // Display string
	*X += size.cx; // advance to end of previous string
	ReleaseDC(hwnd, hdc); // release device context
}

/*----------------------------------------------------------------------
-- FUNCTION:	ClearScreen
--
-- DATE:		January 19, 2018
--
-- DESIGNER:	Luke Lee
--
-- PROGRAMMER:	Luke Lee
--
-- INTERFACE:	void ClearScreen(HWND hwnd)
--
-- ARGUMENT:	hwnd		- Windows handle access GUI information
--
-- RETURNS:		void
--
-- NOTES:
-- This function draws a filled rectangle with the same color as Windows
-- background and the same size as device context area where characters
-- are to be printed. This creates an effect of erasing existing
-- characters on the screen if there was any.
----------------------------------------------------------------------*/
void tcpudp::ClearScreen(HWND hwnd)
{
	RECT winRect;
	RECT rect;
	HDC hdc = GetDC(hwnd);

	if (GetWindowRect(hwnd, &winRect))
	{
		rect.top = INITIAL_Y;
		rect.left = INITIAL_X;
		rect.bottom = winRect.bottom;
		rect.right = winRect.right;

		FillRect(hdc, &rect, (HBRUSH)GetStockObject(WHITE_BRUSH));
	}
}

/*----------------------------------------------------------------------
-- FUNCTION:	CleanUp
--
-- DATE:		January 19, 2018
--
-- DESIGNER:	Luke Lee
--
-- PROGRAMMER:	Luke Lee
--
-- INTERFACE:	void CleanUp()
--
-- ARGUMENT:	void
--
-- RETURNS:		void
--
-- NOTES:
-- This function is responsible for cleaning up memory and terminating
-- the program. The char array storing user input is clear in
-- this case before program termination.
----------------------------------------------------------------------*/
void tcpudp::CleanUp()
{
	delete clntInfo;
	delete svrInfo;

	if (input != NULL)
	{
		delete[] input;
	}
	if (staInfo != nullptr)
	{
		delete staInfo;
	}
	PostQuitMessage(0);
}